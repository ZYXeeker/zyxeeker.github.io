<!DOCTYPE html>
<html lang="en">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>日志器（一）基础功能</title>
<meta name="keywords" content="日志器（一）基础功能, Hexo">
<meta name="description" content="对于以往常用的输出调用方式来说，我们希望可以像 printf 那样可以指定输出格式，同时也可以像 cout 那样使用 &lt;&lt; 来进行方便快捷的输出
接口设计所以可以大致设计如下接口：
class Logger &#123; pub">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="日志器（一）基础功能">
<meta property="og:description" content="对于以往常用的输出调用方式来说，我们希望可以像 printf 那样可以指定输出格式，同时也可以像 cout 那样使用 &lt;&lt; 来进行方便快捷的输出
接口设计所以可以大致设计如下接口：
class Logger &#123; pub">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 7.1.1"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://example.com">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="http://example.com">
        <h1 class="site-title">Hexo</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">日志器（一）基础功能</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-03-29</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/c/">
              c++
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p>对于以往常用的输出调用方式来说，我们希望可以像 <code>printf</code> 那样可以指定输出格式，同时也可以像 <code>cout</code> 那样使用 <code>&lt;&lt;</code> 来进行方便快捷的输出</p>
<h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>所以可以大致设计如下接口：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Logger</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构建C风格输出</span></span><br><span class="line"><span class="comment">   * @param format 输出格式</span></span><br><span class="line"><span class="comment">   * @param ... 输出的参数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Logger</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 流输出方式 重写输入运算符</span></span><br><span class="line"><span class="comment">   * @tparam T 模板参数来适应不同类型的参数传递</span></span><br><span class="line"><span class="comment">   * @param value 需要打印的参数</span></span><br><span class="line"><span class="comment">   * @return 返回自身引用用于多次 &lt;&lt; 调用, 比如 &lt;&lt; ... &lt;&lt; ...</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  Logger&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> T&amp; value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><p>针对输入运算符 <code>&lt;&lt;</code> 只需要将我们传递的值直接传递给 <code>std::cout</code> 打印出来即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line">Logger&amp; Logger::<span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> T &amp;value) &#123;</span><br><span class="line">  std::cout &lt;&lt; value;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>Logger(const char* format, ...)</code> 的实现，使用可变参数即可实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Logger::<span class="built_in">Logger</span>(<span class="type">const</span> <span class="type">char</span>* format, ...) &#123;</span><br><span class="line">  va_list args;</span><br><span class="line">  <span class="built_in">va_start</span>(args, format);</span><br><span class="line">  <span class="comment">// 通过 vsnprintf 计算出所需的字符串长度</span></span><br><span class="line">  <span class="keyword">auto</span> len = <span class="built_in">vsnprintf</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, format, args);</span><br><span class="line">  <span class="comment">// 使用 vector 创建 buffer, 并初始化为 0</span></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buf</span><span class="params">(len + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 使用 vsnprintf 填入到目标 buffer 内</span></span><br><span class="line">  <span class="built_in">vsnprintf</span>(buf.<span class="built_in">data</span>(), buf.<span class="built_in">size</span>(), format, args);</span><br><span class="line">  <span class="built_in">va_end</span>(args);</span><br><span class="line">  std::cout &lt;&lt; buf.<span class="built_in">data</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出测试"><a href="#输出测试" class="headerlink" title="输出测试"></a>输出测试</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Logger.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">  <span class="built_in">Logger</span>(<span class="string">&quot;HELLO %s, %d\n&quot;</span>, <span class="string">&quot;TEST#&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Logger</span>() &lt;&lt; <span class="string">&quot;HELLO &quot;</span> &lt;&lt; <span class="string">&quot;TEST#&quot;</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HELLO TEST#1</span><br><span class="line">HELLO TEST#2</span><br></pre></td></tr></table></figure>
<p>也许你在测试的时候会发现 <code>std::endl</code> 无法应用到 <code>&lt;&lt;</code> 中，这是因为 <code>std::endl</code> 是一个模板函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Elem</span>, <span class="keyword">class</span> <span class="title class_">_Traits</span>&gt;</span><br><span class="line"><span class="function">basic_ostream&lt;_Elem, _Traits&gt;&amp; __CLRCALL_OR_CDECL <span class="title">endl</span><span class="params">(basic_ostream&lt;_Elem, _Traits&gt;&amp; _Ostr)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里暂时只考虑 <code>char</code> 字符的传递和输出，因此可以用 <code>std::ostream</code> 来作为类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ostream = basic_ostream&lt;<span class="type">char</span>, char_traits&lt;<span class="type">char</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>
<p>这样就可以增加一个函数来适配：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于适配 std::endl, std::ends, std::flush</span></span><br><span class="line"><span class="comment"> * @param func 函数指针</span></span><br><span class="line"><span class="comment"> * @return 返回自身引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Logger&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; (*func)(std::ostream&amp;));</span><br></pre></td></tr></table></figure>
<p>实现同 <code>&lt;&lt;</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Logger&amp; Logger::<span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; (*func)(std::ostream&amp;)) &#123;</span><br><span class="line">  std::cout &lt;&lt; func;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="这就完了？"><a href="#这就完了？" class="headerlink" title="这就完了？"></a>这就完了？</h2><p>既然使用 C++ 怎么能不用上 OOP 的思维 😉</p>
<blockquote>
<p> 13：Use objects to manage resources.<br>    —– 《Effective C++》</p>
</blockquote>
<p><code>Logger</code> 为一个对象，可以在对象释放的时候将缓冲的字符串全部输出出来，或者用于其他地方<br>因此可以增加一个 <code>std::ostringstream</code> 成员来用于缓存所需要输出的字符串：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在对象析构时处理缓存的字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  ~<span class="built_in">Logger</span>();</span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于存储缓冲字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  std::ostringstream oss_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为什么使用 <code>std::ostringstream</code> ？<br>它实现了 <code>&lt;&lt;</code> 运算符，这样就无需对各个类型进行重复实现，所以对应的 <code>std::cout &lt;&lt; func</code> 可以修改成 <code>oss_ &lt;&lt; func</code><br>最后一步实现析构函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Logger::~<span class="built_in">Logger</span>() &#123;</span><br><span class="line">  std::cout &lt;&lt; oss_.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Logger</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构建C风格输出</span></span><br><span class="line"><span class="comment">   * @param format 输出格式</span></span><br><span class="line"><span class="comment">   * @param ... 输出的参数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Logger</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在对象析构时输出字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ~<span class="built_in">Logger</span>();</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 流输出方式 重写输入运算符</span></span><br><span class="line"><span class="comment">   * @tparam T 模板参数来适应不同类型的参数传递</span></span><br><span class="line"><span class="comment">   * @param value 需要打印的参数</span></span><br><span class="line"><span class="comment">   * @return 返回自身引用用于多次 &lt;&lt; 调用, 比如 &lt;&lt; ... &lt;&lt; ...</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  Logger&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> T&amp; value);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于适配 std::endl, std::ends, std::flush</span></span><br><span class="line"><span class="comment">   * @param func 函数指针</span></span><br><span class="line"><span class="comment">   * @return 返回自身引用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Logger&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; (*func)(std::ostream&amp;));</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于存储缓冲字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  std::ostringstream oss_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Logger::<span class="built_in">Logger</span>(<span class="type">const</span> <span class="type">char</span>* format, ...) &#123;</span><br><span class="line">  va_list args;</span><br><span class="line">  <span class="built_in">va_start</span>(args, format);</span><br><span class="line">  <span class="comment">// 通过 vsnprintf 计算出所需的字符串长度</span></span><br><span class="line">  <span class="keyword">auto</span> len = <span class="built_in">vsnprintf</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, format, args);</span><br><span class="line">  <span class="comment">// 使用 vector 创建 buffer, 并初始化为 0</span></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buf</span><span class="params">(len + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 使用 vsnprintf 填入到目标 buffer 内</span></span><br><span class="line">  <span class="built_in">vsnprintf</span>(buf.<span class="built_in">data</span>(), buf.<span class="built_in">size</span>(), format, args);</span><br><span class="line">  <span class="built_in">va_end</span>(args);</span><br><span class="line">  oss_ &lt;&lt; buf.<span class="built_in">data</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger::~<span class="built_in">Logger</span>() &#123;</span><br><span class="line">  std::cout &lt;&lt; oss_.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Logger&amp; Logger::<span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> T &amp;value) &#123;</span><br><span class="line">  oss_ &lt;&lt; value;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger&amp; Logger::<span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; (*func)(std::ostream&amp;)) &#123;</span><br><span class="line">  oss_ &lt;&lt; func;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="top-box-text">接口设计</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="top-box-text">如何实现？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E8%BE%93%E5%87%BA%E6%B5%8B%E8%AF%95"><span class="top-box-text">输出测试</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E8%BF%99%E5%B0%B1%E5%AE%8C%E4%BA%86%EF%BC%9F"><span class="top-box-text">这就完了？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="top-box-text">完整代码</span></a></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2024/03/28/hello-world/">
          <h3 class="post-title">
            下一篇：Hello World
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  </body>
</html>

