<!DOCTYPE html>
<html lang="zh">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>程序性能优化 —— 循环优化</title>
<meta name="keywords" content="程序性能优化 —— 循环优化, ZYXeeker`s blog">
<meta name="description" content="
「程序性能优化理论与方法」一些笔记由于作者是使用的 X86 平台进行的测试，考虑到手上实际的设备和环境，这些更偏向于理论硬件 &amp; 版本依据：ARM A53，ARM GCC 11.1.0

前言代码中其实很多逻辑均为循环，虽然在大多">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="程序性能优化 —— 循环优化">
<meta property="og:description" content="
「程序性能优化理论与方法」一些笔记由于作者是使用的 X86 平台进行的测试，考虑到手上实际的设备和环境，这些更偏向于理论硬件 &amp; 版本依据：ARM A53，ARM GCC 11.1.0

前言代码中其实很多逻辑均为循环，虽然在大多">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 7.1.1"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://blog.zyxeeker.top">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://blog.zyxeeker.top">
        <h1 class="site-title">ZYXeeker`s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/memo" class="menu purple-link">
        便笺
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">程序性能优化 —— 循环优化</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-11-22</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/HPC/">
              HPC
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <blockquote>
<p>「程序性能优化理论与方法」一些笔记<br>由于作者是使用的 X86 平台进行的测试，考虑到手上实际的设备和环境，这些更偏向于理论<br>硬件 &amp; 版本依据：ARM A53，ARM GCC 11.1.0</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>代码中其实很多逻辑均为循环，虽然在大多数情况下编译器能够进行很好的优化，但遇到复杂逻辑结构时会造成不确定性优化。因此，通过手动优化循环结构是更加好的选择，这里总结一些常用的方法</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="循环不变量外提"><a href="#循环不变量外提" class="headerlink" title="循环不变量外提"></a>循环不变量外提</h2><p>将循环中的不变量外提是一种很常见的优化方式，同时也是编译器常见的优化手段</p>
<h2 id="循环合并"><a href="#循环合并" class="headerlink" title="循环合并"></a>循环合并</h2><p>循环合并是指将具有相同迭代空间的多个循环合并成一个循环的一种优化手段，合并的目的是为了提供并行化优化。虽然书上提到了即使也会导致优化不成功的例子，但经过尝试似乎并没有出现对应的情况，这里推测可能复杂度不高的代码对于具有多发射特性的处理器来说影响不是很大</p>
<h2 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h2><p>循环展开通过将循环体内的代码复制多次操作，进而减少循环分支指令执行的次数，提升处理器指令调度的空间，以此获得更多的指令级并行。在循环展开后的循环体内可以发掘更多的数据级并行以此来获得更高的性能，修改书上的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N       512</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENABLE_INT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELEM_T  int</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELEM_T  double</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_loop_1</span><span class="params">(ELEM_T A[][N], ELEM_T B[][N], ELEM_T C[][N])</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">      A[i][j] = A[i][j] + B[i][j] * C[i][j];</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_loop_2</span><span class="params">(ELEM_T A[][N], ELEM_T B[][N], ELEM_T C[][N])</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j+=<span class="number">4</span>) &#123;</span><br><span class="line">      A[i][j] = A[i][j] + B[i][j] * C[i][j];</span><br><span class="line">      A[i][j + <span class="number">1</span>] = A[i][j + <span class="number">1</span>] + B[i][j + <span class="number">1</span>] * C[i][j + <span class="number">1</span>];</span><br><span class="line">      A[i][j + <span class="number">2</span>] = A[i][j + <span class="number">2</span>] + B[i][j + <span class="number">2</span>] * C[i][j + <span class="number">2</span>];</span><br><span class="line">      A[i][j + <span class="number">3</span>] = A[i][j + <span class="number">3</span>] + B[i][j + <span class="number">3</span>] * C[i][j + <span class="number">3</span>];</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argv, <span class="type">char</span>* args[])</span> &#123;</span><br><span class="line">  ELEM_T A[N][N], B[N][N], C[N][N];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">time_start</span>, <span class="title">time_end</span>;</span></span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">      A[i][j] = <span class="number">1.f</span>;</span><br><span class="line">      B[i][j] = <span class="number">2.f</span>;</span><br><span class="line">      C[i][j] = <span class="number">3.f</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clock_gettime(CLOCK_BOOTTIME, &amp;time_start);</span><br><span class="line">  <span class="keyword">if</span> (argv &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    func_loop_1(A, B, C);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    func_loop_2(A, B, C);</span><br><span class="line">  &#125;</span><br><span class="line">  clock_gettime(CLOCK_BOOTTIME, &amp;time_end);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s spent: %ld us\n&quot;</span>, argv &lt; <span class="number">2</span> ? <span class="string">&quot;func_loop_1&quot;</span> : <span class="string">&quot;func_loop_2&quot;</span>, (time_end.tv_nsec - time_start.tv_nsec) / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用不同的类型和编译优化等级进行测试：</p>
<ul>
<li><code>int</code> &amp; <em>-O0</em> ：  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./test &amp;&amp; ./test 1</span></span><br><span class="line">func_loop_1 spent: 11804 us</span><br><span class="line">func_loop_2 spent: 12206 us</span><br></pre></td></tr></table></figure></li>
<li><code>int</code> &amp; <em>-O2</em> ：  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./test 10 &amp;&amp; ./test 1</span></span><br><span class="line">func_loop_1 spent: 3101 us</span><br><span class="line">func_loop_2 spent: 2932 us</span><br></pre></td></tr></table></figure></li>
<li><code>double</code> &amp; <em>-O0</em> ：  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./test &amp;&amp; ./test 1</span></span><br><span class="line">func_loop_1 spent: 15437 us</span><br><span class="line">func_loop_2 spent: 14987 us</span><br></pre></td></tr></table></figure></li>
<li><code>double</code> &amp; <em>-O2</em> ：  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./test &amp;&amp; ./test 1</span></span><br><span class="line">func_loop_1 spent: 5655 us</span><br><span class="line">func_loop_2 spent: 5523 us</span><br></pre></td></tr></table></figure>
不难看出，通过手动循环展开的代码会比通过 <em>-O2</em> 的向量化优化后的结果更好，所以其实最好的优化方式依然是从源代码上出发。这是依靠编译器对代码向量化优化，手工向量化循环会取得更好的结果<br>同时选择展开次数也是十分的重要，修改上述代码：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N       1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELEM_T  double</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_loop_1</span><span class="params">(ELEM_T A[][N], ELEM_T B[][N], ELEM_T C[][N])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">      A[i][j] = A[i][j] + B[i][j] * C[i][j];</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_loop_2</span><span class="params">(ELEM_T A[][N], ELEM_T B[][N], ELEM_T C[][N])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j+=<span class="number">2</span>) &#123;</span><br><span class="line">      A[i][j] = A[i][j] + B[i][j] * C[i][j];</span><br><span class="line">      A[i][j + <span class="number">1</span>] = A[i][j + <span class="number">1</span>] + B[i][j + <span class="number">1</span>] * C[i][j + <span class="number">1</span>];</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_loop_4</span><span class="params">(ELEM_T A[][N], ELEM_T B[][N], ELEM_T C[][N])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j+=<span class="number">4</span>) &#123;</span><br><span class="line">      A[i][j] = A[i][j] + B[i][j] * C[i][j];</span><br><span class="line">      A[i][j + <span class="number">1</span>] = A[i][j + <span class="number">1</span>] + B[i][j + <span class="number">1</span>] * C[i][j + <span class="number">1</span>];</span><br><span class="line">      A[i][j + <span class="number">2</span>] = A[i][j + <span class="number">2</span>] + B[i][j + <span class="number">2</span>] * C[i][j + <span class="number">2</span>];</span><br><span class="line">      A[i][j + <span class="number">3</span>] = A[i][j + <span class="number">3</span>] + B[i][j + <span class="number">3</span>] * C[i][j + <span class="number">3</span>];</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_loop_8</span><span class="params">(ELEM_T A[][N], ELEM_T B[][N], ELEM_T C[][N])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j+=<span class="number">8</span>) &#123;</span><br><span class="line">      A[i][j] = A[i][j] + B[i][j] * C[i][j];</span><br><span class="line">      A[i][j + <span class="number">1</span>] = A[i][j + <span class="number">1</span>] + B[i][j + <span class="number">1</span>] * C[i][j + <span class="number">1</span>];</span><br><span class="line">      A[i][j + <span class="number">2</span>] = A[i][j + <span class="number">2</span>] + B[i][j + <span class="number">2</span>] * C[i][j + <span class="number">2</span>];</span><br><span class="line">      A[i][j + <span class="number">3</span>] = A[i][j + <span class="number">3</span>] + B[i][j + <span class="number">3</span>] * C[i][j + <span class="number">3</span>];</span><br><span class="line">      A[i][j + <span class="number">4</span>] = A[i][j + <span class="number">4</span>] + B[i][j + <span class="number">4</span>] * C[i][j + <span class="number">4</span>];</span><br><span class="line">      A[i][j + <span class="number">5</span>] = A[i][j + <span class="number">5</span>] + B[i][j + <span class="number">5</span>] * C[i][j + <span class="number">5</span>];</span><br><span class="line">      A[i][j + <span class="number">6</span>] = A[i][j + <span class="number">6</span>] + B[i][j + <span class="number">6</span>] * C[i][j + <span class="number">6</span>];</span><br><span class="line">      A[i][j + <span class="number">7</span>] = A[i][j + <span class="number">7</span>] + B[i][j + <span class="number">7</span>] * C[i][j + <span class="number">7</span>];</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_loop_10</span><span class="params">(ELEM_T A[][N], ELEM_T B[][N], ELEM_T C[][N])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j+=<span class="number">10</span>) &#123;</span><br><span class="line">      A[i][j] = A[i][j] + B[i][j] * C[i][j];</span><br><span class="line">      A[i][j + <span class="number">1</span>] = A[i][j + <span class="number">1</span>] + B[i][j + <span class="number">1</span>] * C[i][j + <span class="number">1</span>];</span><br><span class="line">      A[i][j + <span class="number">2</span>] = A[i][j + <span class="number">2</span>] + B[i][j + <span class="number">2</span>] * C[i][j + <span class="number">2</span>];</span><br><span class="line">      A[i][j + <span class="number">3</span>] = A[i][j + <span class="number">3</span>] + B[i][j + <span class="number">3</span>] * C[i][j + <span class="number">3</span>];</span><br><span class="line">      A[i][j + <span class="number">4</span>] = A[i][j + <span class="number">4</span>] + B[i][j + <span class="number">4</span>] * C[i][j + <span class="number">4</span>];</span><br><span class="line">      A[i][j + <span class="number">5</span>] = A[i][j + <span class="number">5</span>] + B[i][j + <span class="number">5</span>] * C[i][j + <span class="number">5</span>];</span><br><span class="line">      A[i][j + <span class="number">6</span>] = A[i][j + <span class="number">6</span>] + B[i][j + <span class="number">6</span>] * C[i][j + <span class="number">6</span>];</span><br><span class="line">      A[i][j + <span class="number">7</span>] = A[i][j + <span class="number">7</span>] + B[i][j + <span class="number">7</span>] * C[i][j + <span class="number">7</span>];</span><br><span class="line">      A[i][j + <span class="number">8</span>] = A[i][j + <span class="number">8</span>] + B[i][j + <span class="number">8</span>] * C[i][j + <span class="number">8</span>];</span><br><span class="line">      A[i][j + <span class="number">9</span>] = A[i][j + <span class="number">9</span>] + B[i][j + <span class="number">9</span>] * C[i][j + <span class="number">9</span>];</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> A = <span class="keyword">new</span> ELEM_T[N][N];</span><br><span class="line">  <span class="keyword">auto</span> B = <span class="keyword">new</span> ELEM_T[N][N];</span><br><span class="line">  <span class="keyword">auto</span> C = <span class="keyword">new</span> ELEM_T[N][N];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">timespec</span> time_start, time_end;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">      A[i][j] = <span class="number">1.f</span>;</span><br><span class="line">      B[i][j] = <span class="number">2.f</span>;</span><br><span class="line">      C[i][j] = <span class="number">3.f</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">clock_gettime</span>(CLOCK_BOOTTIME, &amp;time_start);</span><br><span class="line">  <span class="built_in">func_loop_1</span>(A, B, C);</span><br><span class="line">  <span class="built_in">clock_gettime</span>(CLOCK_BOOTTIME, &amp;time_end);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;func_loop_1 %ld us\n&quot;</span>, (time_end.tv_nsec - time_start.tv_nsec) / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">clock_gettime</span>(CLOCK_BOOTTIME, &amp;time_start);</span><br><span class="line">  <span class="built_in">func_loop_2</span>(A, B, C);</span><br><span class="line">  <span class="built_in">clock_gettime</span>(CLOCK_BOOTTIME, &amp;time_end);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;func_loop_2 %ld us\n&quot;</span>, (time_end.tv_nsec - time_start.tv_nsec) / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">clock_gettime</span>(CLOCK_BOOTTIME, &amp;time_start);</span><br><span class="line">  <span class="built_in">func_loop_4</span>(A, B, C);</span><br><span class="line">  <span class="built_in">clock_gettime</span>(CLOCK_BOOTTIME, &amp;time_end);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;func_loop_4 %ld us\n&quot;</span>, (time_end.tv_nsec - time_start.tv_nsec) / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">clock_gettime</span>(CLOCK_BOOTTIME, &amp;time_start);</span><br><span class="line">  <span class="built_in">func_loop_8</span>(A, B, C);</span><br><span class="line">  <span class="built_in">clock_gettime</span>(CLOCK_BOOTTIME, &amp;time_end);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;func_loop_8 %ld us\n&quot;</span>, (time_end.tv_nsec - time_start.tv_nsec) / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">clock_gettime</span>(CLOCK_BOOTTIME, &amp;time_start);</span><br><span class="line">  <span class="built_in">func_loop_10</span>(A, B, C);</span><br><span class="line">  <span class="built_in">clock_gettime</span>(CLOCK_BOOTTIME, &amp;time_end);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;func_loop_10 %ld us\n&quot;</span>, (time_end.tv_nsec - time_start.tv_nsec) / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span>[] A;</span><br><span class="line">  <span class="keyword">delete</span>[] B;</span><br><span class="line">  <span class="keyword">delete</span>[] C;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
通过 <em>-O0</em> 和 <em>-O2</em> 得到的不同的结果：</li>
<li><em>-O0</em>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./test</span></span><br><span class="line">func_loop_1 56799 us</span><br><span class="line">func_loop_2 55125 us</span><br><span class="line">func_loop_4 54264 us</span><br><span class="line">func_loop_8 53811 us</span><br><span class="line">func_loop_10 53870 us</span><br></pre></td></tr></table></figure></li>
<li><em>-O2</em>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./test</span></span><br><span class="line">func_loop_1 18926 us</span><br><span class="line">func_loop_2 18515 us</span><br><span class="line">func_loop_4 18809 us</span><br><span class="line">func_loop_8 19068 us</span><br><span class="line">func_loop_10 18635 us</span><br></pre></td></tr></table></figure>
所以选择以 4 为步进不一定是个很好的选择，要根据不同的平台做出合适的选择</li>
</ul>
<h2 id="循环分段"><a href="#循环分段" class="headerlink" title="循环分段"></a>循环分段</h2><p>可以将单层循环拆成两层嵌套循环，分段的段长可以根据需要选取。如果原循环是可并行化循环，那么即使分段后依然可以实施并行化变化。分段后的外层循环可以采用多线程等并行化技术来发掘任务级并行，而内层循环可以使用向量化技术来做到数据级并行，比如采用数据和任务并行的矩阵计算：<br>![[loop-optz.svg]]<br>任务数的划分根据处理器个数来计算：</p>
<p>$$<br>K &#x3D; \frac{N}{P}<br>$$</p>
<p>其中，<em>N</em> 为迭代次数，<em>P</em> 为处理器个数，<em>K</em> 为每个处理器上分到的迭代次数</p>
<h2 id="循环分块"><a href="#循环分块" class="headerlink" title="循环分块"></a>循环分块</h2><p>循环分块是对多重循环的迭代空间进行重新划分，其目的是为了提高缓存命中率以及解决大于设备内存容量数组的情况。简化书上的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// N = 256, A[N][N], B[N][N], C[N][N]</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">      C[i][j] = C[i][j] + A[i][k] * B[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对 <em>k</em> 层的循环中，$C(1:N, j)$ 这个范围的数据会被用到，但当出现 <em>Cache</em> 不足以容纳这个范围的数据时，则会出现缓存未命中的情况增加循环时间。因此，可以将 <em>i</em> 层循环进行分块，倘若分成 <em>M</em> 块，那么所使用的数据范围将会变成 $C(1:\frac{N}{M}, j)$，同时将 <em>i</em> 层循环提到最外层，改变迭代的顺序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// N = 256, A[N][N], B[N][N], C[N][N]</span></span><br><span class="line"><span class="comment">// M = 4</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i+=M) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; k++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (I = i; I &lt; i + M; I++) &#123;</span><br><span class="line">	    C[I][j] = C[I][j] + A[I][k] * B[k][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也不难看出 <em>k</em> 和 <em>j</em> 的循环也是可以进行同样的优化处理。最关键的点在于选择分块的数量，太少不能充分利用性能，太多收益可能不如不优化<br><em>-O3</em> 一般会启用编译器的分块优化方案，但是通常情况下不会用到这个等级，而且分块的好坏也取决于编译器内置的算法如何，所以需要根据硬件情况手动进行分块是最好的方案</p>
<h2 id="循环交换"><a href="#循环交换" class="headerlink" title="循环交换"></a>循环交换</h2><p>循环交换对原有的循环并没有做出修改，而是调整了迭代的顺序。一般可以从<strong>寄存器重用</strong>和<strong>内存连续性</strong>两方面出发，简化书上代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// N = 256, A[N][N], B[N][N], C[N][N]</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; k++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">	  A[i][j] = A[i][j] + B[i][k] * C[k][j];</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>寄存器重用<br>  可以将 <em>i</em> 循环提至外层，这样 <code>C[i][j]</code> 在内部就可以作为不变量，利于编译器将其优化成寄存器进行运算，减少 <em>LOAD</em> 和 <em>STORE</em> 的次数：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// N = 256, A[N][N], B[N][N], C[N][N]</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; k++) &#123;</span><br><span class="line">      A[i][j] = A[i][j] + B[i][k] * C[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>内存连续性<br>  不难看出内循环中的矩阵 <em>A</em> 和矩阵 <em>C</em> 在 <em>j</em> 的索引下具有内存连续性的特性，因此可以做这样的修改促使编译器进行向量化优化：  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// N = 256, A[N][N], B[N][N], C[N][N]</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">      A[i][j] = A[i][j] + B[i][k] * C[k][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="循环分布"><a href="#循环分布" class="headerlink" title="循环分布"></a>循环分布</h2><p>循环分布是将一个循环分解成多个循环，每个循环都和原循环具有相同的迭代空间，但只包含原循环语句的语句子集。比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// N = 256, A[N], B[N]</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">  A[i + <span class="number">1</span>] = A[i] + <span class="number">10</span>;   <span class="comment">// S1</span></span><br><span class="line">  B[i] = B[i] + <span class="number">20</span>;       <span class="comment">// S2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将 <em>S1</em> 与 <em>S2</em> 拆开，<em>S2</em> 可以通过 SIMD 进行实现，这样有利于编译器进行更好的优化</p>
<h2 id="循环分裂"><a href="#循环分裂" class="headerlink" title="循环分裂"></a>循环分裂</h2><p>这个和循环分布不同，分裂开来的循环不具有相同的迭代空间，这也是一种很常见的做法。比如将一个大循环中的不同阶段进行分裂，然后正确实现每部分的代码促进编译器进行优化</p>
<h2 id="循环倾斜"><a href="#循环倾斜" class="headerlink" title="循环倾斜"></a>循环倾斜</h2><p>用于改变迭代空间，发掘循环中的并行性。书上例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// N 8 A[N][N]</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">    A[i][j] = A[i - <span class="number">1</span>][j] + A[i][j - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照上述编写的逻辑，不难看出循环的次序：<br>![[loop-slope1.svg]]<br>其实可以看出整体的依赖计算顺序是这样的：<br>![[loop-slope2.svg]]<br>如果需要计算 $(2,1)$ 和 $(1,2)$ 两者的值，按照上面的写法需要读取两次 $(1,1)$ 然后进行计算，那么为什么不可以在访问到它的同时计算出两者的值呢？于是经过倾斜后，循环迭代的逻辑就可以变换成这样：<br>![[loop-slope3.svg]]</p>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E5%89%8D%E8%A8%80"><span class="top-box-text">前言</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E6%96%B9%E6%B3%95"><span class="top-box-text">方法</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E9%87%8F%E5%A4%96%E6%8F%90"><span class="top-box-text">循环不变量外提</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%BE%AA%E7%8E%AF%E5%90%88%E5%B9%B6"><span class="top-box-text">循环合并</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80"><span class="top-box-text">循环展开</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%BE%AA%E7%8E%AF%E5%88%86%E6%AE%B5"><span class="top-box-text">循环分段</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%BE%AA%E7%8E%AF%E5%88%86%E5%9D%97"><span class="top-box-text">循环分块</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%BE%AA%E7%8E%AF%E4%BA%A4%E6%8D%A2"><span class="top-box-text">循环交换</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%BE%AA%E7%8E%AF%E5%88%86%E5%B8%83"><span class="top-box-text">循环分布</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%BE%AA%E7%8E%AF%E5%88%86%E8%A3%82"><span class="top-box-text">循环分裂</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%BE%AA%E7%8E%AF%E5%80%BE%E6%96%9C"><span class="top-box-text">循环倾斜</span></a></li></ol></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2024/11/14/HPC-code/">
          <h3 class="post-title">
            下一篇：程序性能优化 —— 过程优化
          </h3>
        </a>
      </div>
    
  </div>


    <div id="gitalk-container"></div>






<script>
    (function () {
        const jq = document.createElement('script');
        jq.src = "/js/twikoo.min.js";
        document.getElementsByTagName('body')[0].appendChild(jq);

        const config = {"envId":"https://zyxeeker-blog.hf.space","region":null,"mark":null};
        jq.onload = function () {
            twikoo.init({
                envId: config.envId,
                el: '#gitalk-container',
                region: config.region,
                path: location.pathname + (config.mark ? '?mark=' + config.mark : ''),
                lang: config.language,
            });
        }
    })()
</script>




<footer>
    <div class="site-footer">
        <div class="social-container">
            
            
            <a aria-label="跳转至github" href="https://github.com/zyxeeker" target="_blank">
                <i class="icon icon-github"></i>
            </a>
            
            
            
            
            
            
            
            
            
            
        </div>
        
        Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a
            href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
        
        
        
        
        
        
    </div>
    <!-- mermaid -->
    <script src="https://cdn.bootcdn.net/ajax/libs/mermaid/10.9.0/mermaid.min.js"></script>
    <script>
        if (window.mermaid) {
            // 检查用户的首选颜色模式
            const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
            mermaid.initialize({
                theme: isDarkMode ? 'neutral' : 'base'
            });
        }
    </script>
    <!-- diagrams -->
    <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
    <style type="text/css">
        @media (prefers-color-scheme: dark) {
            svg {
                filter: invert(93%) hue-rotate(180deg);
                background-color: transparent !important;
            }

            image {
                filter: invert(100%) hue-rotate(180deg) saturate(1.25);
            }
        }

        .mxgraph-container {
            display: flex;
            justify-content: center;
        }
    </style>
</footer>


</div>
</div>

<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






</body>

</html>

