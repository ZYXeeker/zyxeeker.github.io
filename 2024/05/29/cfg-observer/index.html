<!DOCTYPE html>
<html lang="zh">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>C++中配置监听设计</title>
<meta name="keywords" content="C++中配置监听设计, ZYXeeker`s blog">
<meta name="description" content="
本文是对上篇文章（C++中配置转换设计）的运用前置知识：模板，完美转发，智能指针，设计模式-监听模式

场景运用在项目中有时需要对一些配置变量发生改动时进行回调监听，不仅发生在被其他调用者修改的场景，也可能存在对应的配置管理器需要监听文件">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="C++中配置监听设计">
<meta property="og:description" content="
本文是对上篇文章（C++中配置转换设计）的运用前置知识：模板，完美转发，智能指针，设计模式-监听模式

场景运用在项目中有时需要对一些配置变量发生改动时进行回调监听，不仅发生在被其他调用者修改的场景，也可能存在对应的配置管理器需要监听文件">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 7.1.1"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://blog.zyxeeker.top">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://blog.zyxeeker.top">
        <h1 class="site-title">ZYXeeker`s blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/memo" class="menu purple-link">
        便笺
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">C++中配置监听设计</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-05-29</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/C/">
              C++
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <blockquote>
<p>本文是对上篇文章（<a href="/2024/05/24/cfg-cvt">C++中配置转换设计</a>）的运用<br>前置知识：模板，完美转发，智能指针，设计模式-监听模式</p>
</blockquote>
<h1 id="场景运用"><a href="#场景运用" class="headerlink" title="场景运用"></a>场景运用</h1><p>在项目中有时需要对一些配置变量发生改动时进行回调监听，不仅发生在被其他调用者修改的场景，也可能存在对应的配置管理器需要监听文件变动来触发热更新这类的场景，所以我们希望：</p>
<ul>
<li>当值发生更新时能通过绑定的回调得到新老值来触发对应的业务逻辑</li>
<li>可以由绑定的调用者来控制回调的生命周期</li>
<li>配置管理器可以通过传递对应的对象来触发转发和回调</li>
</ul>
<h1 id="如何设计"><a href="#如何设计" class="headerlink" title="如何设计"></a>如何设计</h1><p>整体可以采用<strong>监听模式</strong>来设计，部分细节如下：</p>
<h2 id="监听回调设计"><a href="#监听回调设计" class="headerlink" title="监听回调设计"></a>监听回调设计</h2><p>对于监听回调来说，可以采用多种方法来注册对应的回调函数给观察者，但同时也需要使用者来对回调的生命周期进行控制，当然难免会出现生命周期控制不当的情况，所以这里采用更加优雅的方式来减少出现这种问题的情况<br>将监听回调视为一个观察者的子模块，因此可以在里面保存对应的回调函数以及自身的标识：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObserverObj</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 监听回调子模块</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Id = <span class="type">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> Callback = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> var::Base*, <span class="type">const</span> var::Base*)&gt;;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Listener</span><span class="params">(Id id, Callback cb)</span></span></span><br><span class="line"><span class="function">        : id_(id), cb_(std::move(cb)) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Listener</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写()操作符用于在更新时调用所存储的回调</span></span><br><span class="line"><span class="comment">     * @param old_val 旧值</span></span><br><span class="line"><span class="comment">     * @param new_val 新值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> var::Base* old_val, <span class="type">const</span> var::Base* new_val)</span> </span>&#123;</span><br><span class="line">	  <span class="keyword">if</span> (cb_) <span class="built_in">cb_</span>(old_val, new_val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回自身Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Id <span class="title">id</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> id_; &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 监听者id</span></span><br><span class="line">    Id id_;</span><br><span class="line">    <span class="comment">// 所储存的回调用于更新时调用</span></span><br><span class="line">    Callback cb_;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="观察者设计"><a href="#观察者设计" class="headerlink" title="观察者设计"></a>观察者设计</h2><p>那么对于观察者来说，可以使用 <code>std::map</code> 对监听回调对象进行存储和管理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObserverObj</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 监听回调子模块</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> Ptr = std::shared_ptr&lt;Listener&gt;;</span><br><span class="line">    <span class="keyword">using</span> WPtr = std::weak_ptr&lt;Listener&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 存储监听者回调对象</span></span><br><span class="line">  std::map&lt;Listener::Id, Listener::WPtr&gt; listeners_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于需要将回调对象的生命周期交予调用者管理，所以注册接口的返回值和反注册接口的参数均为回调对象。对于注册接口的设计，为了调用者在不需要通过 <code>std::bind</code> 等方法进行绑定后再传递进来，可以考虑传递对应的函数等指针在内部进一步封装：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObserverObj</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注册回调函数, 用于普通函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">typename</span> Listener::Ptr <span class="title">RegisterListener</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">const</span> T*, <span class="type">const</span> T*))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cb = [func](<span class="type">const</span> var::Base* old_val, <span class="type">const</span> var::Base* new_val) &#123;</span><br><span class="line">      (*func)(<span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> T*&gt;(old_val), <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> T*&gt;(new_val));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegisterListenerImpl</span>(cb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注册回调函数, 用于类成员函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Class</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">typename</span> Listener::Ptr <span class="title">RegisterListener</span><span class="params">(<span class="type">void</span> (Class::*func)(<span class="type">const</span> T*, <span class="type">const</span> T*), Class *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cb = [c, func](<span class="type">const</span> var::Base* old_val, <span class="type">const</span> var::Base* new_val) &#123;</span><br><span class="line">      (c-&gt;*func)(<span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> T*&gt;(old_val), <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> T*&gt;(new_val));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegisterListenerImpl</span>(cb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 反注册监听回调</span></span><br><span class="line"><span class="comment">   * @param listener 监听回调对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">UnregisterListener</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Listener::Ptr&amp; listener)</span> </span>&#123;</span><br><span class="line">    listeners_.<span class="built_in">erase</span>(listener-&gt;<span class="built_in">id</span>());</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注册监听实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">typename</span> Listener::Ptr <span class="title">RegisterListenerImpl</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Listener::Callback&amp; cb)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::<span class="type">atomic_uint64_t</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> listener = std::<span class="built_in">make_shared</span>&lt;Listener&gt;(id++, cb);</span><br><span class="line">    listeners_.<span class="built_in">insert</span>(&#123;listener-&gt;<span class="built_in">id</span>(), listener&#125;);</span><br><span class="line">    <span class="keyword">return</span> listener;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总体定义"><a href="#总体定义" class="headerlink" title="总体定义"></a>总体定义</h2><p>因此总体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObserverObj</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 监听回调子模块</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Ptr = std::shared_ptr&lt;Listener&gt;;</span><br><span class="line">    <span class="keyword">using</span> WPtr = std::weak_ptr&lt;Listener&gt;;</span><br><span class="line">    <span class="keyword">using</span> Id = <span class="type">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> Callback = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> var::Base*, <span class="type">const</span> var::Base*)&gt;;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Listener</span><span class="params">(Id id, Callback cb)</span></span></span><br><span class="line"><span class="function">        : id_(id), cb_(std::move(cb)) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Listener</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写()操作符用于在更新时调用所存储的回调</span></span><br><span class="line"><span class="comment">     * @param old_val 旧值</span></span><br><span class="line"><span class="comment">     * @param new_val 新值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> var::Base* old_val, <span class="type">const</span> var::Base* new_val)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回自身Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Id <span class="title">id</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> id_; &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 监听者id</span></span><br><span class="line">    Id id_;</span><br><span class="line">    <span class="comment">// 所储存的回调用于更新时调用</span></span><br><span class="line">    Callback cb_;</span><br><span class="line">  &#125;;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ObserverObj</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">      : var_(std::make_shared&lt;T&gt;(std::forward&lt;Args&gt;(args)...)) &#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ObserverObj</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">      : var_(std::make_shared&lt;T&gt;(val)) &#123;</span>&#125;</span><br><span class="line">  ~<span class="built_in">ObserverObj</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于对应类型值进行更新</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用Json对象来进行更新</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">const</span> nlohmann::json&amp; json)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注册回调函数, 用于普通函数</span></span><br><span class="line"><span class="comment">   * @return 返回监听对象指针, 交给调用者控制生命周期</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Listener::Ptr <span class="title">RegisterListener</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">const</span> T*, <span class="type">const</span> T*))</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注册回调函数, 用于类成员函数</span></span><br><span class="line"><span class="comment">   * @return 返回监听对象指针, 交给调用者控制生命周期</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Class</span>&gt;</span><br><span class="line">  <span class="function">Listener::Ptr <span class="title">RegisterListener</span><span class="params">(<span class="type">void</span> (Class::*func)(<span class="type">const</span> T*, <span class="type">const</span> T*), Class *c)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 反注册监听回调</span></span><br><span class="line"><span class="comment">   * @param listener 监听回调对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">UnregisterListener</span><span class="params">(<span class="type">const</span> Listener::Ptr&amp; listener)</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 存储以var::Base为基类的值</span></span><br><span class="line">  std::shared_ptr&lt;var::Base&gt; var_;</span><br><span class="line">  <span class="comment">// 存储监听者回调对象</span></span><br><span class="line">  std::map&lt;<span class="keyword">typename</span> Listener::Id, <span class="keyword">typename</span> Listener::WPtr&gt; listeners_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 UML 可以表示如下：</p>
<pre class="mermaid">classDiagram
direction LR
    class ObserverObj~T~ {
        + Update(const T& val)
        + Update(const nlohmann::json& json)
        + RegisterListener(void (*func)(const T*, const T*)) Listener::Ptr
        + RegisterListener~Class~(void (Class::*func)(const T*, const T*), Class *c) Listener::Ptr
        + UnregisterListener(const Listener::Ptr& listener)
        - var_ : std::shared_ptr~T~
        - listeners_ : std::map~Listener::Id, Listener::WPtr~
    }
    class Listener {
        + operator()(const var::Base* old_val, const var::Base* new_val)
        + id() : Id
        - id_ : Id
        - cb_ : Callback
    }
    ObserverObj*--Listener : << 监听回调子模块 >>
    note for Listener "using Ptr = std::shared_ptr&lt;Listener&gt;
        using WPtr = std::weak_ptr&lt;Listener&gt;
        using Id = size_t;
        using Callback = std::function&lt;void(const var::Base*, const var::Base*)&gt;"</pre>
<h1 id="问题？"><a href="#问题？" class="headerlink" title="问题？"></a>问题？</h1><p>但这样的定义会有问题，当我们需要使用容器存储以及管理对应的 <code>ObserverObj</code> 时，需要明确类型，但是即使在明确类型的情况下也不能使用同一个容器进行存储，因为不同类型的大小会导致类的内存布局发生变化，所以这样不能很好的对接以后的配置管理器</p>
<h1 id="改进设计"><a href="#改进设计" class="headerlink" title="改进设计"></a>改进设计</h1><p>因此可以增加一个非模板类来作为模板类的基类，同时将 Json 对象的 <code>Update()</code> 作为基类的接口，这样继承的模板类就只用于处理类型转换，基类进行值和监听回调的存储和管理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObserverBaseObj</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 监听回调子模块</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Listener</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Ptr = std::shared_ptr&lt;Listener&gt;;</span><br><span class="line">    <span class="keyword">using</span> WPtr = std::weak_ptr&lt;Listener&gt;;</span><br><span class="line">    <span class="keyword">using</span> Id = <span class="type">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> Callback = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> var::Base*, <span class="type">const</span> var::Base*)&gt;;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Listener</span><span class="params">(Id id, Callback cb)</span></span></span><br><span class="line"><span class="function">        : id_(id), cb_(std::move(cb)) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Listener</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写()操作符用于在更新时调用所存储的回调</span></span><br><span class="line"><span class="comment">     * @param old_val 旧值</span></span><br><span class="line"><span class="comment">     * @param new_val 新值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> var::Base* old_val, <span class="type">const</span> var::Base* new_val)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回自身Id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Id <span class="title">id</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> id_; &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 监听者id</span></span><br><span class="line">    Id id_;</span><br><span class="line">    <span class="comment">// 所储存的回调用于更新时调用</span></span><br><span class="line">    Callback cb_;</span><br><span class="line">  &#125;;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ObserverBaseObj</span><span class="params">(std::shared_ptr&lt;var::Base&gt; var)</span></span></span><br><span class="line"><span class="function">      : var_(std::move(var)) &#123;</span>&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">ObserverBaseObj</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将Json对象转换接口作为虚函数的原因如下:</span></span><br><span class="line"><span class="comment">   * 1. 用于对接配置管理器的Json值更新, 需要继承的子类去确定对象并实现</span></span><br><span class="line"><span class="comment">   * 2. 用于其他调用者可能会传入Json值进行更新</span></span><br><span class="line"><span class="comment">   * @param json json值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">const</span> nlohmann::json&amp; json)</span> </span>= <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加监听回调</span></span><br><span class="line"><span class="comment">   * @param listener 监听者指针</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddListener</span><span class="params">(<span class="type">const</span> Listener::Ptr&amp; listener)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 移除指定的添加监听回调</span></span><br><span class="line"><span class="comment">   * @param id 监听者指针</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">RemoveListener</span><span class="params">(<span class="type">const</span> Listener::Ptr&amp; listener)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通知所有已注册回调进行更新</span></span><br><span class="line"><span class="comment">   * @param new_val 新值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">NotifyChange</span><span class="params">(<span class="type">const</span> var::Base* new_val)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回保存的var</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> std::shared_ptr&lt;var::Base&gt; <span class="title">var</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> var_;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 存储以var::Base为基类的值</span></span><br><span class="line">  std::shared_ptr&lt;var::Base&gt; var_;</span><br><span class="line">  <span class="comment">// 存储监听者回调对象</span></span><br><span class="line">  std::map&lt;Listener::Id, Listener::WPtr&gt; listeners_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>UML 所示：</p>
<pre class="mermaid">classDiagram
direction LR
    class ObserverBaseObj {
        + Update(const nlohmann::json& json)*
        # AddListener(const Listener::Ptr& listener)
        # RemoveListener(const Listener::Ptr& listener)
        # NotifyChange(const var::Base* new_val)
        # var() std::shared_ptr~var::Base~
        - var_ : std::shared_ptr~var::Base~
        - listeners_ : std::map~Listener::Id, Listener::WPtr~
    }
    class Listener {
        + operator()(const var::Base* old_val, const var::Base* new_val)
        + id() : Id
        - id_ : Id
        - cb_ : Callback
    }
    ObserverBaseObj*--Listener : << 监听回调子模块 >>
    note for Listener "using Ptr = std::shared_ptr&lt;Listener&gt;
        using WPtr = std::weak_ptr&lt;Listener&gt;
        using Id = size_t;
        using Callback = std::function&lt;void(const var::Base*, const var::Base*)&gt;"</pre>
<p>那么 <code>ObserverObj</code> 就可以继承 <code>ObserverBaseObj</code> 进行实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObserverObj</span> : <span class="keyword">protected</span> ObserverBaseObj &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ObserverObj</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">  : ObserverBaseObj(std::make_shared&lt;T&gt;(std::forward&lt;Args&gt;(args)...)) &#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ObserverObj</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">      : ObserverBaseObj(std::make_shared&lt;T&gt;(val)) &#123;</span>&#125;</span><br><span class="line">  ~<span class="built_in">ObserverObj</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于对应类型值进行更新</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用Json对象来进行更新</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">const</span> nlohmann::json&amp; json)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注册回调函数, 用于普通函数</span></span><br><span class="line"><span class="comment">   * @return 返回监听对象指针, 交给调用者控制生命周期</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Listener::Ptr <span class="title">RegisterListener</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">const</span> T*, <span class="type">const</span> T*))</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注册回调函数, 用于类成员函数</span></span><br><span class="line"><span class="comment">   * @return 返回监听对象指针, 交给调用者控制生命周期</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Class</span>&gt;</span><br><span class="line">  <span class="function">Listener::Ptr <span class="title">RegisterListener</span><span class="params">(<span class="type">void</span> (Class::*func)(<span class="type">const</span> T*, <span class="type">const</span> T*), Class *c)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 反注册监听回调</span></span><br><span class="line"><span class="comment">   * @param listener 监听回调对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">UnregisterListener</span><span class="params">(<span class="type">const</span> Listener::Ptr&amp; listener)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因此整体 UML 如下：</p>
<pre class="mermaid">classDiagram
direction LR
    class ObserverBaseObj {
        + Update(const nlohmann::json& json)*
        # AddListener(const Listener::Ptr& listener)
        # RemoveListener(const Listener::Ptr& listener)
        # NotifyChange(const var::Base* new_val)
        # var() std::shared_ptr~var::Base~
        - var_ : std::shared_ptr~var::Base~
        - listeners_ : std::map~Listener::Id, Listener::WPtr~
    }
    class Listener {
        + operator()(const var::Base* old_val, const var::Base* new_val)
        + id() : Id
        - id_ : Id
        - cb_ : Callback
    }
    class ObserverObj~T~ {
        + Update(const T& val)
        + RegisterListener(void (*func)(const T*, const T*)) Listener::Ptr
        + RegisterListener~Class~(void (Class::*func)(const T*, const T*), Class *c) Listener::Ptr
        + UnregisterListener(const Listener::Ptr& listener)
    }
    ObserverBaseObj <|-- ObserverObj~T~ : 实现
    ObserverBaseObj*--Listener : << 监听回调子模块 >>
    note for Listener "using Ptr = std::shared_ptr&lt;Listener&gt;
        using WPtr = std::weak_ptr&lt;Listener&gt;
        using Id = size_t;
        using Callback = std::function&lt;void(const var::Base*, const var::Base*)&gt;"</pre>
<h1 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h1><p>源码定义：<a target="_blank" rel="noopener" href="https://github.com/zyxeeker/tools/blob/main/include/var.hpp">tools&#x2F;include&#x2F;var.hpp at main · zyxeeker&#x2F;tools · GitHub</a><br>测试用例：<a target="_blank" rel="noopener" href="https://github.com/zyxeeker/tools/blob/main/tests/test_var.cpp">tools&#x2F;tests&#x2F;test_var.cpp at main · zyxeeker&#x2F;tools · GitHub</a></p>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E5%9C%BA%E6%99%AF%E8%BF%90%E7%94%A8"><span class="top-box-text">场景运用</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1"><span class="top-box-text">如何设计</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E7%9B%91%E5%90%AC%E5%9B%9E%E8%B0%83%E8%AE%BE%E8%AE%A1"><span class="top-box-text">监听回调设计</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1"><span class="top-box-text">观察者设计</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%80%BB%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="top-box-text">总体定义</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="top-box-text">问题？</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E6%94%B9%E8%BF%9B%E8%AE%BE%E8%AE%A1"><span class="top-box-text">改进设计</span></a></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0"><span class="top-box-text">完整实现</span></a></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2024/05/24/cfg-cvt/">
          <h3 class="post-title">
            下一篇：C++中配置转换设计
          </h3>
        </a>
      </div>
    
  </div>


    <div id="gitalk-container"></div>






<script>
    (function () {
        const jq = document.createElement('script');
        jq.src = "/js/twikoo.min.js";
        document.getElementsByTagName('body')[0].appendChild(jq);

        const config = {"envId":"https://zyxeeker-blog.hf.space","region":null,"mark":null};
        jq.onload = function () {
            twikoo.init({
                envId: config.envId,
                el: '#gitalk-container',
                region: config.region,
                path: location.pathname + (config.mark ? '?mark=' + config.mark : ''),
                lang: config.language,
            });
        }
    })()
</script>




<footer>
    <div class="site-footer">
        <div class="social-container">
            
            
            <a aria-label="跳转至github" href="https://github.com/zyxeeker" target="_blank">
                <i class="icon icon-github"></i>
            </a>
            
            
            
            
            
            
            
            
            
            
        </div>
        
        Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a
            href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
        
        
        
        
        
        
    </div>
    <!-- mermaid -->
    <script src="https://cdn.bootcdn.net/ajax/libs/mermaid/10.9.1/mermaid.min.js"></script>
    <script>
        if (window.mermaid) {
            // 检查用户的首选颜色模式
            const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
            mermaid.initialize({
                theme: isDarkMode ? 'neutral' : 'base'
            });
        }
    </script>
    <!-- diagrams -->
    <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
    <style type="text/css">
        .MathJax svg {
          filter: none;
        }
        @media (prefers-color-scheme: dark) {
            svg {
                filter: invert(93%) hue-rotate(180deg);
                background-color: transparent !important;
            }

            image {
                filter: invert(100%) hue-rotate(180deg) saturate(1.25);
            }
        }

        .mxgraph-container {
            display: flex;
            justify-content: center;
        }
    </style>
</footer>


</div>
</div>

<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






</body>

</html>

