<!DOCTYPE html>
<html lang="en">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>日志器（二）文件名, 函数名, 行号</title>
<meta name="keywords" content="日志器（二）文件名, 函数名, 行号, Hexo">
<meta name="description" content="在调用日志输出的时候，我们希望在输出的时候可以同时输出被调用处的文件名，函数名，行号甚至是线程名&#x2F;ID
修改接口所以可以在构造函数处添加 const char* file, const char* function, uint64">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="日志器（二）文件名, 函数名, 行号">
<meta property="og:description" content="在调用日志输出的时候，我们希望在输出的时候可以同时输出被调用处的文件名，函数名，行号甚至是线程名&#x2F;ID
修改接口所以可以在构造函数处添加 const char* file, const char* function, uint64">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 7.1.1"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://example.com">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="http://example.com">
        <h1 class="site-title">Hexo</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">日志器（二）文件名, 函数名, 行号</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-04-01</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/tags/c/">
              c++
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p>在调用日志输出的时候，我们希望在输出的时候可以同时输出被调用处的文件名，函数名，行号甚至是线程名&#x2F;ID</p>
<h2 id="修改接口"><a href="#修改接口" class="headerlink" title="修改接口"></a>修改接口</h2><p>所以可以在构造函数处添加 <code>const char* file, const char* function, uint64_t line</code>，用来传递被调用处的文件名，函数名和行号：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构建流式输出</span></span><br><span class="line"><span class="comment">   * @param file 文件名</span></span><br><span class="line"><span class="comment">   * @param function 函数名</span></span><br><span class="line"><span class="comment">   * @param line 行号</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">Logger</span>(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* function, <span class="type">uint64_t</span> line);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构建C风格输出</span></span><br><span class="line"><span class="comment">   * @param file 文件名</span></span><br><span class="line"><span class="comment">   * @param function 函数名</span></span><br><span class="line"><span class="comment">   * @param line 行号</span></span><br><span class="line"><span class="comment">   * @param format 输出格式</span></span><br><span class="line"><span class="comment">   * @param ... 输出的参数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Logger</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* function, <span class="type">uint64_t</span> line, <span class="type">const</span> <span class="type">char</span>* format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>增加成员变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 文件名</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* file_;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 函数名</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* function_;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 行号</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">uint64_t</span> line_;</span><br></pre></td></tr></table></figure>
<p>构造函数实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Logger::<span class="built_in">Logger</span>(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* function, <span class="type">uint64_t</span> line)</span><br><span class="line">  : <span class="built_in">file_</span>(file),</span><br><span class="line">    <span class="built_in">function_</span>(function),</span><br><span class="line">    <span class="built_in">line_</span>(line) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Logger::<span class="built_in">Logger</span>(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* function, <span class="type">uint64_t</span> line, <span class="type">const</span> <span class="type">char</span>* format, ...)</span><br><span class="line">  : <span class="built_in">file_</span>(file),</span><br><span class="line">    <span class="built_in">function_</span>(function),</span><br><span class="line">    <span class="built_in">line_</span>(line) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完善下析构函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Logger::~<span class="built_in">Logger</span>() &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; file_ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; line_ &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; function_  &lt;&lt; <span class="string">&quot;)]&quot;</span></span><br><span class="line">            &lt;&lt; oss_.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出测试"><a href="#输出测试" class="headerlink" title="输出测试"></a>输出测试</h2><p>使用 <code>__FILE__</code> ，<code>__FUNCTION__</code> ，<code>__LINE__</code> 三个宏来帮助我们获取相关的参数：</p>
<ul>
<li><code>__FILE__</code>：获取函数所在的文件名</li>
<li><code>__FUNCTION__</code>：获取当前函数名</li>
<li><code>__LINE__</code>：获取当前行号<br>带入测试输出：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Logger</span>(__FILE__, __FUNCTION__, __LINE__, <span class="string">&quot;HELLO %s#%d\n&quot;</span>, <span class="string">&quot;TEST&quot;</span>, <span class="number">1</span>);  </span><br><span class="line"><span class="built_in">Logger</span>(__FILE__, __FUNCTION__, __LINE__) &lt;&lt; <span class="string">&quot;HELLO &quot;</span> &lt;&lt; <span class="string">&quot;TEST#&quot;</span> &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
测试输出：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[D:\WorkSpace\tools\tests\test_Logger.cpp:13(main)]HELLO TEST#1</span><br><span class="line">[D:\WorkSpace\tools\tests\test_Logger.cpp:14(main)]HELLO TEST#2</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>使用这种写法在调用的时候会异常的麻烦，同时也导致很多不必要的代码，所以可以使用宏函数来帮助我们填入 <code>__FILE__</code> ，<code>__FUNCTION__</code> ，<code>__LINE__</code> ：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_F(...) Logger(__FILE__, __FUNCTION__, __LINE__, __VA_ARGS__)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_S()    Logger(__FILE__, __FUNCTION__, __LINE__)</span></span><br></pre></td></tr></table></figure>
<p>那么调用也可以变成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Logger(__FILE__, __FUNCTION__, __LINE__, &quot;HELLO %s#%d\n&quot;, &quot;TEST&quot;, 1);</span></span><br><span class="line">  <span class="comment">// Logger(__FILE__, __FUNCTION__, __LINE__) &lt;&lt; &quot;HELLO &quot; &lt;&lt; &quot;TEST#&quot; &lt;&lt; 2 &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="built_in">LOG_F</span>(<span class="string">&quot;HELLO %s#%d\n&quot;</span>, <span class="string">&quot;TEST&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">LOG_S</span>() &lt;&lt; <span class="string">&quot;HELLO &quot;</span> &lt;&lt; <span class="string">&quot;TEST#&quot;</span> &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就方便了很多</p>
<h2 id="再更进一步？"><a href="#再更进一步？" class="headerlink" title="再更进一步？"></a>再更进一步？</h2><p>这样宏定义对于使用者来说并未方便，同一个目的功能的接口以不为重载的方式分为了两者，需要使用者考虑在什么情况下调用合适的接口，这样反而不够方便，所以可以考虑合二为一<br>由于宏不能够重载，所以可以考虑将 C 风格的输入转换为 C++ 的字符串通过流的方式输入到缓冲区，因此可以增加一个<strong>静态</strong>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 用于转换C风格输入为C++标准字符串</span></span><br><span class="line"><span class="comment">* @param format 输出格式</span></span><br><span class="line"><span class="comment">* @param ... 输出的参数</span></span><br><span class="line"><span class="comment">* @return 标准字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::string <span class="title">CStringToStdString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format = <span class="literal">nullptr</span>, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">Logger::CStringToStdString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置 format 默认为空, 若为空, 返回空字符串</span></span><br><span class="line">  <span class="keyword">if</span> (!format) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  va_list args;</span><br><span class="line">  <span class="built_in">va_start</span>(args, format);</span><br><span class="line">  <span class="comment">// 通过 vsnprintf 计算出所需的字符串长度</span></span><br><span class="line">  <span class="keyword">auto</span> len = <span class="built_in">vsnprintf</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, format, args);</span><br><span class="line">  <span class="comment">// 使用 vector 创建 buffer, 并初始化为 0</span></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buf</span><span class="params">(len + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 使用 vsnprintf 填入到目标 buffer 内</span></span><br><span class="line">  <span class="built_in">vsnprintf</span>(buf.<span class="built_in">data</span>(), buf.<span class="built_in">size</span>(), format, args);</span><br><span class="line">  <span class="built_in">va_end</span>(args);</span><br><span class="line">  <span class="keyword">return</span> buf.<span class="built_in">data</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此宏函数可以修改成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(...) LOG(__FILE__, __FUNCTION__, __LINE__) &lt;&lt; Logger::CStringToStdString(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LOG</span>(<span class="string">&quot;HELLO %s#%d\n&quot;</span>, <span class="string">&quot;TEST&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">LOG</span>() &lt;&lt; <span class="string">&quot;HELLO &quot;</span> &lt;&lt; <span class="string">&quot;TEST#&quot;</span> &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>输出和前者一样，因此无需保留 C 风格输出的构造函数了</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(...) Logger(__FILE__, __FUNCTION__, __LINE__) &lt;&lt; Logger::CStringToStdString(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构建流式输出</span></span><br><span class="line"><span class="comment">   * @param file 文件名</span></span><br><span class="line"><span class="comment">   * @param function 函数名</span></span><br><span class="line"><span class="comment">   * @param line 行号</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">Logger</span>(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* function, <span class="type">uint64_t</span> line);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在对象析构时处理缓存的字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ~<span class="built_in">Logger</span>();</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于转换C风格输入为C++标准字符串</span></span><br><span class="line"><span class="comment">   * @param format 输出格式</span></span><br><span class="line"><span class="comment">   * @param ... 输出的参数</span></span><br><span class="line"><span class="comment">   * @return 标准字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">static</span> std::string <span class="title">CStringToStdString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format = <span class="literal">nullptr</span>, ...)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 流输出方式 重写输入运算符</span></span><br><span class="line"><span class="comment">   * @tparam T 模板参数来适应不同类型的参数传递</span></span><br><span class="line"><span class="comment">   * @param value 需要打印的参数</span></span><br><span class="line"><span class="comment">   * @return 返回自身引用用于多次 &lt;&lt; 调用, 比如 &lt;&lt; ... &lt;&lt; ...</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  Logger&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> T&amp; value);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于适配 std::endl, std::ends, std::flush</span></span><br><span class="line"><span class="comment">   * @param func 函数指针</span></span><br><span class="line"><span class="comment">   * @return 返回自身引用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Logger&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; (*func)(std::ostream&amp;));</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用于存储缓冲字符串</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  std::ostringstream oss_;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 文件名</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* file_;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 函数名</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* function_;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 行号</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">uint64_t</span> line_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Logger::<span class="built_in">Logger</span>(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* function, <span class="type">uint64_t</span> line)</span><br><span class="line">  : <span class="built_in">file_</span>(file),</span><br><span class="line">    <span class="built_in">function_</span>(function),</span><br><span class="line">    <span class="built_in">line_</span>(line) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Logger::~<span class="built_in">Logger</span>() &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; file_ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; line_ &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; function_  &lt;&lt; <span class="string">&quot;)]&quot;</span></span><br><span class="line">            &lt;&lt; oss_.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">Logger::CStringToStdString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* format, ...)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 设置 format 默认为空, 若为空, 返回空字符串</span></span><br><span class="line">  <span class="keyword">if</span> (!format) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  va_list args;</span><br><span class="line">  <span class="built_in">va_start</span>(args, format);</span><br><span class="line">  <span class="comment">// 通过 vsnprintf 计算出所需的字符串长度</span></span><br><span class="line">  <span class="keyword">auto</span> len = <span class="built_in">vsnprintf</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, format, args);</span><br><span class="line">  <span class="comment">// 使用 vector 创建 buffer, 并初始化为 0</span></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buf</span><span class="params">(len + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 使用 vsnprintf 填入到目标 buffer 内</span></span><br><span class="line">  <span class="built_in">vsnprintf</span>(buf.<span class="built_in">data</span>(), buf.<span class="built_in">size</span>(), format, args);</span><br><span class="line">  <span class="built_in">va_end</span>(args);</span><br><span class="line">  <span class="keyword">return</span> buf.<span class="built_in">data</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Logger&amp; Logger::<span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> T &amp;value) &#123;</span><br><span class="line">  oss_ &lt;&lt; value;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger&amp; Logger::<span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; (*func)(std::ostream&amp;)) &#123;</span><br><span class="line">  oss_ &lt;&lt; func;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%BF%AE%E6%94%B9%E6%8E%A5%E5%8F%A3"><span class="top-box-text">修改接口</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E8%BE%93%E5%87%BA%E6%B5%8B%E8%AF%95"><span class="top-box-text">输出测试</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5"><span class="top-box-text">更进一步</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%86%8D%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5%EF%BC%9F"><span class="top-box-text">再更进一步？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="top-box-text">完整代码</span></a></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2024/03/29/logger_1/">
          <h3 class="post-title">
            下一篇：日志器（一）基础功能
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/f-dong" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  </body>
</html>

